unit Codebot.GLES;

{$mode delphi}
{$macro on}
{$ifdef windows}
  {$define apicall := stdcall}
{$else}
  {$define apicall := cdecl}
{$endif}

interface

type
  GLVULKANPROCNV = pointer;
  GLbitfield = uint32;
  GLboolean = byte;
  GLbyte = int8;
  GLchar = char;
  GLcharARB = byte;
  GLclampd = double;
  GLclampf = single;
  GLclampx = int32;
  GLdouble = double;
  GLeglClientBufferEXT = pointer;
  GLeglImageOES = pointer;
  GLenum = uint32;
  GLfixed = int32;
  GLfloat = single;
  GLhalf = uint16;
  GLhalfARB = uint16;
  GLhalfNV = uint16;
  GLhandleARB = uint32;
  GLint = int32;
  GLint64 = int64;
  GLint64EXT = int64;
  GLintptr = int32;
  GLintptrARB = int32;
  GLshort = int16;
  GLsizei = int32;
  GLsizeiptr = int32;
  GLsizeiptrARB = int32;
  GLsync = pointer;
  GLubyte = uint8;
  GLuint = uint32;
  GLuint64 = uint64;
  GLuint64EXT = uint64;
  GLushort = uint16;
  GLvdpauSurfaceNV = int32;
  GLvoid = pointer;
  _cl_context = pointer;
  _cl_event = pointer;

  PGLbitfield = ^uint32;
  PGLboolean = ^byte;
  PGLbyte = ^int8;
  PGLchar = ^char;
  PGLcharARB = ^byte;
  PGLclampd = ^double;
  PGLclampf = ^single;
  PGLclampx = ^int32;
  PGLdouble = ^double;
  PGLeglClientBufferEXT = ^pointer;
  PGLeglImageOES = ^pointer;
  PGLenum = ^uint32;
  PGLfixed = ^int32;
  PGLfloat = ^single;
  PGLhalf = ^uint16;
  PGLhalfARB = ^uint16;
  PGLhalfNV = ^uint16;
  PGLhandleARB = ^uint32;
  PGLint = ^int32;
  PGLint64 = ^int64;
  PGLint64EXT = ^int64;
  PGLintptr = ^int32;
  PGLintptrARB = ^int32;
  PGLshort = ^int16;
  PGLsizei = ^int32;
  PGLsizeiptr = ^int32;
  PGLsizeiptrARB = ^int32;
  PGLsync = ^pointer;
  PGLubyte = ^uint8;
  PGLuint = ^uint32;
  PGLuint64 = ^uint64;
  PGLuint64EXT = ^uint64;
  PGLushort = ^uint16;
  PGLvdpauSurfaceNV = ^int32;
  PGLvoid = ^pointer;
  P_cl_context = ^pointer;
  P_cl_event = ^pointer;
  PPGLchar = ^PGLchar;
  PPGLcharARB = ^PGLcharARB;
  PPGLboolean = ^PGLboolean;

const
  GL_FALSE = 0;
  GL_INVALID_INDEX = uint32($FFFFFFFF);
  GL_NONE = 0;
  GL_NONE_OES = 0;
  GL_NO_ERROR = 0;
  GL_ONE = 1;
  GL_TIMEOUT_IGNORED = uint64($FFFFFFFFFFFFFFFF);
  GL_TIMEOUT_IGNORED_APPLE = uint64($FFFFFFFFFFFFFFFF);
  GL_TRUE = 1;
  GL_VERSION_ES_CL_1_0 = 1;
  GL_VERSION_ES_CL_1_1 = 1;
  GL_VERSION_ES_CM_1_1 = 1;
  GL_ZERO = 0;

  GL_DEPTH_BUFFER_BIT = $00000100;
  GL_STENCIL_BUFFER_BIT = $00000400;
  GL_COLOR_BUFFER_BIT = $00004000;
  GL_POINTS = $0000;
  GL_LINES = $0001;
  GL_LINE_LOOP = $0002;
  GL_LINE_STRIP = $0003;
  GL_TRIANGLES = $0004;
  GL_TRIANGLE_STRIP = $0005;
  GL_TRIANGLE_FAN = $0006;
  GL_SRC_COLOR = $0300;
  GL_ONE_MINUS_SRC_COLOR = $0301;
  GL_SRC_ALPHA = $0302;
  GL_ONE_MINUS_SRC_ALPHA = $0303;
  GL_DST_ALPHA = $0304;
  GL_ONE_MINUS_DST_ALPHA = $0305;
  GL_DST_COLOR = $0306;
  GL_ONE_MINUS_DST_COLOR = $0307;
  GL_SRC_ALPHA_SATURATE = $0308;
  GL_FUNC_ADD = $8006;
  GL_BLEND_EQUATION = $8009;
  GL_BLEND_EQUATION_RGB = $8009;
  GL_BLEND_EQUATION_ALPHA = $883D;
  GL_FUNC_SUBTRACT = $800A;
  GL_FUNC_REVERSE_SUBTRACT = $800B;
  GL_BLEND_DST_RGB = $80C8;
  GL_BLEND_SRC_RGB = $80C9;
  GL_BLEND_DST_ALPHA = $80CA;
  GL_BLEND_SRC_ALPHA = $80CB;
  GL_CONSTANT_COLOR = $8001;
  GL_ONE_MINUS_CONSTANT_COLOR = $8002;
  GL_CONSTANT_ALPHA = $8003;
  GL_ONE_MINUS_CONSTANT_ALPHA = $8004;
  GL_BLEND_COLOR = $8005;
  GL_ARRAY_BUFFER = $8892;
  GL_ELEMENT_ARRAY_BUFFER = $8893;
  GL_ARRAY_BUFFER_BINDING = $8894;
  GL_ELEMENT_ARRAY_BUFFER_BINDING = $8895;
  GL_STREAM_DRAW = $88E0;
  GL_STATIC_DRAW = $88E4;
  GL_DYNAMIC_DRAW = $88E8;
  GL_BUFFER_SIZE = $8764;
  GL_BUFFER_USAGE = $8765;
  GL_CURRENT_VERTEX_ATTRIB = $8626;
  GL_FRONT = $0404;
  GL_BACK = $0405;
  GL_FRONT_AND_BACK = $0408;
  GL_TEXTURE_2D = $0DE1;
  GL_CULL_FACE = $0B44;
  GL_BLEND = $0BE2;
  GL_DITHER = $0BD0;
  GL_STENCIL_TEST = $0B90;
  GL_DEPTH_TEST = $0B71;
  GL_SCISSOR_TEST = $0C11;
  GL_POLYGON_OFFSET_FILL = $8037;
  GL_SAMPLE_ALPHA_TO_COVERAGE = $809E;
  GL_SAMPLE_COVERAGE = $80A0;
  GL_INVALID_ENUM = $0500;
  GL_INVALID_VALUE = $0501;
  GL_INVALID_OPERATION = $0502;
  GL_OUT_OF_MEMORY = $0505;
  GL_CW = $0900;
  GL_CCW = $0901;
  GL_LINE_WIDTH = $0B21;
  GL_ALIASED_POINT_SIZE_RANGE = $846D;
  GL_ALIASED_LINE_WIDTH_RANGE = $846E;
  GL_CULL_FACE_MODE = $0B45;
  GL_FRONT_FACE = $0B46;
  GL_DEPTH_RANGE = $0B70;
  GL_DEPTH_WRITEMASK = $0B72;
  GL_DEPTH_CLEAR_VALUE = $0B73;
  GL_DEPTH_FUNC = $0B74;
  GL_STENCIL_CLEAR_VALUE = $0B91;
  GL_STENCIL_FUNC = $0B92;
  GL_STENCIL_FAIL = $0B94;
  GL_STENCIL_PASS_DEPTH_FAIL = $0B95;
  GL_STENCIL_PASS_DEPTH_PASS = $0B96;
  GL_STENCIL_REF = $0B97;
  GL_STENCIL_VALUE_MASK = $0B93;
  GL_STENCIL_WRITEMASK = $0B98;
  GL_STENCIL_BACK_FUNC = $8800;
  GL_STENCIL_BACK_FAIL = $8801;
  GL_STENCIL_BACK_PASS_DEPTH_FAIL = $8802;
  GL_STENCIL_BACK_PASS_DEPTH_PASS = $8803;
  GL_STENCIL_BACK_REF = $8CA3;
  GL_STENCIL_BACK_VALUE_MASK = $8CA4;
  GL_STENCIL_BACK_WRITEMASK = $8CA5;
  GL_VIEWPORT = $0BA2;
  GL_SCISSOR_BOX = $0C10;
  GL_COLOR_CLEAR_VALUE = $0C22;
  GL_COLOR_WRITEMASK = $0C23;
  GL_UNPACK_ALIGNMENT = $0CF5;
  GL_PACK_ALIGNMENT = $0D05;
  GL_MAX_TEXTURE_SIZE = $0D33;
  GL_MAX_VIEWPORT_DIMS = $0D3A;
  GL_SUBPIXEL_BITS = $0D50;
  GL_RED_BITS = $0D52;
  GL_GREEN_BITS = $0D53;
  GL_BLUE_BITS = $0D54;
  GL_ALPHA_BITS = $0D55;
  GL_DEPTH_BITS = $0D56;
  GL_STENCIL_BITS = $0D57;
  GL_POLYGON_OFFSET_UNITS = $2A00;
  GL_POLYGON_OFFSET_FACTOR = $8038;
  GL_TEXTURE_BINDING_2D = $8069;
  GL_SAMPLE_BUFFERS = $80A8;
  GL_SAMPLES = $80A9;
  GL_SAMPLE_COVERAGE_VALUE = $80AA;
  GL_SAMPLE_COVERAGE_INVERT = $80AB;
  GL_NUM_COMPRESSED_TEXTURE_FORMATS = $86A2;
  GL_COMPRESSED_TEXTURE_FORMATS = $86A3;
  GL_DONT_CARE = $1100;
  GL_FASTEST = $1101;
  GL_NICEST = $1102;
  GL_GENERATE_MIPMAP_HINT = $8192;
  GL_BYTE = $1400;
  GL_UNSIGNED_BYTE = $1401;
  GL_SHORT = $1402;
  GL_UNSIGNED_SHORT = $1403;
  GL_INT = $1404;
  GL_UNSIGNED_INT = $1405;
  GL_FLOAT = $1406;
  GL_FIXED = $140C;
  GL_DEPTH_COMPONENT = $1902;
  GL_ALPHA = $1906;
  GL_RGB = $1907;
  GL_RGBA = $1908;
  GL_LUMINANCE = $1909;
  GL_LUMINANCE_ALPHA = $190A;
  GL_UNSIGNED_SHORT_4_4_4_4 = $8033;
  GL_UNSIGNED_SHORT_5_5_5_1 = $8034;
  GL_UNSIGNED_SHORT_5_6_5 = $8363;
  GL_FRAGMENT_SHADER = $8B30;
  GL_VERTEX_SHADER = $8B31;
  GL_MAX_VERTEX_ATTRIBS = $8869;
  GL_MAX_VERTEX_UNIFORM_VECTORS = $8DFB;
  GL_MAX_VARYING_VECTORS = $8DFC;
  GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS = $8B4D;
  GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS = $8B4C;
  GL_MAX_TEXTURE_IMAGE_UNITS = $8872;
  GL_MAX_FRAGMENT_UNIFORM_VECTORS = $8DFD;
  GL_SHADER_TYPE = $8B4F;
  GL_DELETE_STATUS = $8B80;
  GL_LINK_STATUS = $8B82;
  GL_VALIDATE_STATUS = $8B83;
  GL_ATTACHED_SHADERS = $8B85;
  GL_ACTIVE_UNIFORMS = $8B86;
  GL_ACTIVE_UNIFORM_MAX_LENGTH = $8B87;
  GL_ACTIVE_ATTRIBUTES = $8B89;
  GL_ACTIVE_ATTRIBUTE_MAX_LENGTH = $8B8A;
  GL_SHADING_LANGUAGE_VERSION = $8B8C;
  GL_CURRENT_PROGRAM = $8B8D;
  GL_NEVER = $0200;
  GL_LESS = $0201;
  GL_EQUAL = $0202;
  GL_LEQUAL = $0203;
  GL_GREATER = $0204;
  GL_NOTEQUAL = $0205;
  GL_GEQUAL = $0206;
  GL_ALWAYS = $0207;
  GL_KEEP = $1E00;
  GL_REPLACE = $1E01;
  GL_INCR = $1E02;
  GL_DECR = $1E03;
  GL_INVERT = $150A;
  GL_INCR_WRAP = $8507;
  GL_DECR_WRAP = $8508;
  GL_VENDOR = $1F00;
  GL_RENDERER = $1F01;
  GL_VERSION = $1F02;
  GL_EXTENSIONS = $1F03;
  GL_NEAREST = $2600;
  GL_LINEAR = $2601;
  GL_NEAREST_MIPMAP_NEAREST = $2700;
  GL_LINEAR_MIPMAP_NEAREST = $2701;
  GL_NEAREST_MIPMAP_LINEAR = $2702;
  GL_LINEAR_MIPMAP_LINEAR = $2703;
  GL_TEXTURE_MAG_FILTER = $2800;
  GL_TEXTURE_MIN_FILTER = $2801;
  GL_TEXTURE_WRAP_S = $2802;
  GL_TEXTURE_WRAP_T = $2803;
  GL_TEXTURE = $1702;
  GL_TEXTURE_CUBE_MAP = $8513;
  GL_TEXTURE_BINDING_CUBE_MAP = $8514;
  GL_TEXTURE_CUBE_MAP_POSITIVE_X = $8515;
  GL_TEXTURE_CUBE_MAP_NEGATIVE_X = $8516;
  GL_TEXTURE_CUBE_MAP_POSITIVE_Y = $8517;
  GL_TEXTURE_CUBE_MAP_NEGATIVE_Y = $8518;
  GL_TEXTURE_CUBE_MAP_POSITIVE_Z = $8519;
  GL_TEXTURE_CUBE_MAP_NEGATIVE_Z = $851A;
  GL_MAX_CUBE_MAP_TEXTURE_SIZE = $851C;
  GL_TEXTURE0 = $84C0;
  GL_TEXTURE1 = $84C1;
  GL_TEXTURE2 = $84C2;
  GL_TEXTURE3 = $84C3;
  GL_TEXTURE4 = $84C4;
  GL_TEXTURE5 = $84C5;
  GL_TEXTURE6 = $84C6;
  GL_TEXTURE7 = $84C7;
  GL_TEXTURE8 = $84C8;
  GL_TEXTURE9 = $84C9;
  GL_TEXTURE10 = $84CA;
  GL_TEXTURE11 = $84CB;
  GL_TEXTURE12 = $84CC;
  GL_TEXTURE13 = $84CD;
  GL_TEXTURE14 = $84CE;
  GL_TEXTURE15 = $84CF;
  GL_TEXTURE16 = $84D0;
  GL_TEXTURE17 = $84D1;
  GL_TEXTURE18 = $84D2;
  GL_TEXTURE19 = $84D3;
  GL_TEXTURE20 = $84D4;
  GL_TEXTURE21 = $84D5;
  GL_TEXTURE22 = $84D6;
  GL_TEXTURE23 = $84D7;
  GL_TEXTURE24 = $84D8;
  GL_TEXTURE25 = $84D9;
  GL_TEXTURE26 = $84DA;
  GL_TEXTURE27 = $84DB;
  GL_TEXTURE28 = $84DC;
  GL_TEXTURE29 = $84DD;
  GL_TEXTURE30 = $84DE;
  GL_TEXTURE31 = $84DF;
  GL_ACTIVE_TEXTURE = $84E0;
  GL_REPEAT = $2901;
  GL_CLAMP_TO_EDGE = $812F;
  GL_MIRRORED_REPEAT = $8370;
  GL_FLOAT_VEC2 = $8B50;
  GL_FLOAT_VEC3 = $8B51;
  GL_FLOAT_VEC4 = $8B52;
  GL_INT_VEC2 = $8B53;
  GL_INT_VEC3 = $8B54;
  GL_INT_VEC4 = $8B55;
  GL_BOOL = $8B56;
  GL_BOOL_VEC2 = $8B57;
  GL_BOOL_VEC3 = $8B58;
  GL_BOOL_VEC4 = $8B59;
  GL_FLOAT_MAT2 = $8B5A;
  GL_FLOAT_MAT3 = $8B5B;
  GL_FLOAT_MAT4 = $8B5C;
  GL_SAMPLER_2D = $8B5E;
  GL_SAMPLER_CUBE = $8B60;
  GL_VERTEX_ATTRIB_ARRAY_ENABLED = $8622;
  GL_VERTEX_ATTRIB_ARRAY_SIZE = $8623;
  GL_VERTEX_ATTRIB_ARRAY_STRIDE = $8624;
  GL_VERTEX_ATTRIB_ARRAY_TYPE = $8625;
  GL_VERTEX_ATTRIB_ARRAY_NORMALIZED = $886A;
  GL_VERTEX_ATTRIB_ARRAY_POINTER = $8645;
  GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = $889F;
  GL_IMPLEMENTATION_COLOR_READ_TYPE = $8B9A;
  GL_IMPLEMENTATION_COLOR_READ_FORMAT = $8B9B;
  GL_COMPILE_STATUS = $8B81;
  GL_INFO_LOG_LENGTH = $8B84;
  GL_SHADER_SOURCE_LENGTH = $8B88;
  GL_SHADER_COMPILER = $8DFA;
  GL_SHADER_BINARY_FORMATS = $8DF8;
  GL_NUM_SHADER_BINARY_FORMATS = $8DF9;
  GL_LOW_FLOAT = $8DF0;
  GL_MEDIUM_FLOAT = $8DF1;
  GL_HIGH_FLOAT = $8DF2;
  GL_LOW_INT = $8DF3;
  GL_MEDIUM_INT = $8DF4;
  GL_HIGH_INT = $8DF5;
  GL_FRAMEBUFFER = $8D40;
  GL_RENDERBUFFER = $8D41;
  GL_RGBA4 = $8056;
  GL_RGB5_A1 = $8057;
  GL_RGB565 = $8D62;
  GL_DEPTH_COMPONENT16 = $81A5;
  GL_STENCIL_INDEX8 = $8D48;
  GL_RENDERBUFFER_WIDTH = $8D42;
  GL_RENDERBUFFER_HEIGHT = $8D43;
  GL_RENDERBUFFER_INTERNAL_FORMAT = $8D44;
  GL_RENDERBUFFER_RED_SIZE = $8D50;
  GL_RENDERBUFFER_GREEN_SIZE = $8D51;
  GL_RENDERBUFFER_BLUE_SIZE = $8D52;
  GL_RENDERBUFFER_ALPHA_SIZE = $8D53;
  GL_RENDERBUFFER_DEPTH_SIZE = $8D54;
  GL_RENDERBUFFER_STENCIL_SIZE = $8D55;
  GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = $8CD0;
  GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = $8CD1;
  GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = $8CD2;
  GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = $8CD3;
  GL_COLOR_ATTACHMENT0 = $8CE0;
  GL_DEPTH_ATTACHMENT = $8D00;
  GL_STENCIL_ATTACHMENT = $8D20;
  GL_FRAMEBUFFER_COMPLETE = $8CD5;
  GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT = $8CD6;
  GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = $8CD7;
  GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS = $8CD9;
  GL_FRAMEBUFFER_UNSUPPORTED = $8CDD;
  GL_FRAMEBUFFER_BINDING = $8CA6;
  GL_RENDERBUFFER_BINDING = $8CA7;
  GL_MAX_RENDERBUFFER_SIZE = $84E8;
  GL_INVALID_FRAMEBUFFER_OPERATION = $0506;

var
  glActiveTexture: procedure (texture: GLenum); apicall;
  glAttachShader: procedure (program_: GLuint; shader: GLuint); apicall;
  glBindAttribLocation: procedure (program_: GLuint; index: GLuint; name: PGLchar); apicall;
  glBindBuffer: procedure (target: GLenum; buffer: GLuint); apicall;
  glBindFramebuffer: procedure (target: GLenum; framebuffer: GLuint); apicall;
  glBindRenderbuffer: procedure (target: GLenum; renderbuffer: GLuint); apicall;
  glBindTexture: procedure (target: GLenum; texture: GLuint); apicall;
  glBlendColor: procedure (red: GLfloat; green: GLfloat; blue: GLfloat; alpha: GLfloat); apicall;
  glBlendEquation: procedure (mode: GLenum); apicall;
  glBlendEquationSeparate: procedure (modeRGB: GLenum; modeAlpha: GLenum); apicall;
  glBlendFunc: procedure (sfactor: GLenum; dfactor: GLenum); apicall;
  glBlendFuncSeparate: procedure (sfactorRGB: GLenum; dfactorRGB: GLenum; sfactorAlpha: GLenum; dfactorAlpha: GLenum); apicall;
  glBufferData: procedure (target: GLenum; size: GLsizeiptr; data: Pointer; usage: GLenum); apicall;
  glBufferSubData: procedure (target: GLenum; offset: GLintptr; size: GLsizeiptr; data: Pointer); apicall;
  glCheckFramebufferStatus: function (target: GLenum): GLenum; apicall;
  glClear: procedure (mask: GLbitfield); apicall;
  glClearColor: procedure (red: GLfloat; green: GLfloat; blue: GLfloat; alpha: GLfloat); apicall;
  glClearDepthf: procedure (d: GLfloat); apicall;
  glClearStencil: procedure (s: GLint); apicall;
  glColorMask: procedure (red: GLboolean; green: GLboolean; blue: GLboolean; alpha: GLboolean); apicall;
  glCompileShader: procedure (shader: GLuint); apicall;
  glCompressedTexImage2D: procedure (target: GLenum; level: GLint; internalformat: GLenum; width: GLsizei; height: GLsizei; border: GLint; imageSize: GLsizei; data: Pointer); apicall;
  glCompressedTexSubImage2D: procedure (target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; width: GLsizei; height: GLsizei; format: GLenum; imageSize: GLsizei; data: Pointer); apicall;
  glCopyTexImage2D: procedure (target: GLenum; level: GLint; internalformat: GLenum; x: GLint; y: GLint; width: GLsizei; height: GLsizei; border: GLint); apicall;
  glCopyTexSubImage2D: procedure (target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; x: GLint; y: GLint; width: GLsizei; height: GLsizei); apicall;
  glCreateProgram: function (): GLuint; apicall;
  glCreateShader: function (type_: GLenum): GLuint; apicall;
  glCullFace: procedure (mode: GLenum); apicall;
  glDeleteBuffers: procedure (n: GLsizei; buffers: PGLuint); apicall;
  glDeleteFramebuffers: procedure (n: GLsizei; framebuffers: PGLuint); apicall;
  glDeleteProgram: procedure (program_: GLuint); apicall;
  glDeleteRenderbuffers: procedure (n: GLsizei; renderbuffers: PGLuint); apicall;
  glDeleteShader: procedure (shader: GLuint); apicall;
  glDeleteTextures: procedure (n: GLsizei; textures: PGLuint); apicall;
  glDepthFunc: procedure (func: GLenum); apicall;
  glDepthMask: procedure (flag: GLboolean); apicall;
  glDepthRangef: procedure (n: GLfloat; f: GLfloat); apicall;
  glDetachShader: procedure (program_: GLuint; shader: GLuint); apicall;
  glDisable: procedure (cap: GLenum); apicall;
  glDisableVertexAttribArray: procedure (index: GLuint); apicall;
  glDrawArrays: procedure (mode: GLenum; first: GLint; count: GLsizei); apicall;
  glDrawElements: procedure (mode: GLenum; count: GLsizei; type_: GLenum; indices: Pointer); apicall;
  glEnable: procedure (cap: GLenum); apicall;
  glEnableVertexAttribArray: procedure (index: GLuint); apicall;
  glFinish: procedure (); apicall;
  glFlush: procedure (); apicall;
  glFramebufferRenderbuffer: procedure (target: GLenum; attachment: GLenum; renderbuffertarget: GLenum; renderbuffer: GLuint); apicall;
  glFramebufferTexture2D: procedure (target: GLenum; attachment: GLenum; textarget: GLenum; texture: GLuint; level: GLint); apicall;
  glFrontFace: procedure (mode: GLenum); apicall;
  glGenBuffers: procedure (n: GLsizei; buffers: PGLuint); apicall;
  glGenerateMipmap: procedure (target: GLenum); apicall;
  glGenFramebuffers: procedure (n: GLsizei; framebuffers: PGLuint); apicall;
  glGenRenderbuffers: procedure (n: GLsizei; renderbuffers: PGLuint); apicall;
  glGenTextures: procedure (n: GLsizei; textures: PGLuint); apicall;
  glGetActiveAttrib: procedure (program_: GLuint; index: GLuint; bufSize: GLsizei; length: PGLsizei; size: PGLint; type_: PGLenum; name: PGLchar); apicall;
  glGetActiveUniform: procedure (program_: GLuint; index: GLuint; bufSize: GLsizei; length: PGLsizei; size: PGLint; type_: PGLenum; name: PGLchar); apicall;
  glGetAttachedShaders: procedure (program_: GLuint; maxCount: GLsizei; count: PGLsizei; shaders: PGLuint); apicall;
  glGetAttribLocation: function (program_: GLuint; name: PGLchar): GLint; apicall;
  glGetBooleanv: procedure (pname: GLenum; data: PGLboolean); apicall;
  glGetBufferParameteriv: procedure (target: GLenum; pname: GLenum; params: PGLint); apicall;
  glGetError: function (): GLenum; apicall;
  glGetFloatv: procedure (pname: GLenum; data: PGLfloat); apicall;
  glGetFramebufferAttachmentParameteriv: procedure (target: GLenum; attachment: GLenum; pname: GLenum; params: PGLint); apicall;
  glGetIntegerv: procedure (pname: GLenum; data: PGLint); apicall;
  glGetProgramiv: procedure (program_: GLuint; pname: GLenum; params: PGLint); apicall;
  glGetProgramInfoLog: procedure (program_: GLuint; bufSize: GLsizei; length: PGLsizei; infoLog: PGLchar); apicall;
  glGetRenderbufferParameteriv: procedure (target: GLenum; pname: GLenum; params: PGLint); apicall;
  glGetShaderiv: procedure (shader: GLuint; pname: GLenum; params: PGLint); apicall;
  glGetShaderInfoLog: procedure (shader: GLuint; bufSize: GLsizei; length: PGLsizei; infoLog: PGLchar); apicall;
  glGetShaderPrecisionFormat: procedure (shadertype: GLenum; precisiontype: GLenum; range: PGLint; precision: PGLint); apicall;
  glGetShaderSource: procedure (shader: GLuint; bufSize: GLsizei; length: PGLsizei; source: PGLchar); apicall;
  glGetString: function (name: GLenum): PGLubyte; apicall;
  glGetTexParameterfv: procedure (target: GLenum; pname: GLenum; params: PGLfloat); apicall;
  glGetTexParameteriv: procedure (target: GLenum; pname: GLenum; params: PGLint); apicall;
  glGetUniformfv: procedure (program_: GLuint; location: GLint; params: PGLfloat); apicall;
  glGetUniformiv: procedure (program_: GLuint; location: GLint; params: PGLint); apicall;
  glGetUniformLocation: function (program_: GLuint; name: PGLchar): GLint; apicall;
  glGetVertexAttribfv: procedure (index: GLuint; pname: GLenum; params: PGLfloat); apicall;
  glGetVertexAttribiv: procedure (index: GLuint; pname: GLenum; params: PGLint); apicall;
  glGetVertexAttribPointerv: procedure (index: GLuint; pname: GLenum; pointer: PPointer); apicall;
  glHint: procedure (target: GLenum; mode: GLenum); apicall;
  glIsBuffer: function (buffer: GLuint): GLboolean; apicall;
  glIsEnabled: function (cap: GLenum): GLboolean; apicall;
  glIsFramebuffer: function (framebuffer: GLuint): GLboolean; apicall;
  glIsProgram: function (program_: GLuint): GLboolean; apicall;
  glIsRenderbuffer: function (renderbuffer: GLuint): GLboolean; apicall;
  glIsShader: function (shader: GLuint): GLboolean; apicall;
  glIsTexture: function (texture: GLuint): GLboolean; apicall;
  glLineWidth: procedure (width: GLfloat); apicall;
  glLinkProgram: procedure (program_: GLuint); apicall;
  glPixelStorei: procedure (pname: GLenum; param: GLint); apicall;
  glPolygonOffset: procedure (factor: GLfloat; units: GLfloat); apicall;
  glReadPixels: procedure (x: GLint; y: GLint; width: GLsizei; height: GLsizei; format: GLenum; type_: GLenum; pixels: Pointer); apicall;
  glReleaseShaderCompiler: procedure (); apicall;
  glRenderbufferStorage: procedure (target: GLenum; internalformat: GLenum; width: GLsizei; height: GLsizei); apicall;
  glSampleCoverage: procedure (value: GLfloat; invert: GLboolean); apicall;
  glScissor: procedure (x: GLint; y: GLint; width: GLsizei; height: GLsizei); apicall;
  glShaderBinary: procedure (count: GLsizei; shaders: PGLuint; binaryformat: GLenum; binary: Pointer; length: GLsizei); apicall;
  glShaderSource: procedure (shader: GLuint; count: GLsizei; string_: PPGLchar; length: PGLint); apicall;
  glStencilFunc: procedure (func: GLenum; ref: GLint; mask: GLuint); apicall;
  glStencilFuncSeparate: procedure (face: GLenum; func: GLenum; ref: GLint; mask: GLuint); apicall;
  glStencilMask: procedure (mask: GLuint); apicall;
  glStencilMaskSeparate: procedure (face: GLenum; mask: GLuint); apicall;
  glStencilOp: procedure (fail: GLenum; zfail: GLenum; zpass: GLenum); apicall;
  glStencilOpSeparate: procedure (face: GLenum; sfail: GLenum; dpfail: GLenum; dppass: GLenum); apicall;
  glTexImage2D: procedure (target: GLenum; level: GLint; internalformat: GLint; width: GLsizei; height: GLsizei; border: GLint; format: GLenum; type_: GLenum; pixels: Pointer); apicall;
  glTexParameterf: procedure (target: GLenum; pname: GLenum; param: GLfloat); apicall;
  glTexParameterfv: procedure (target: GLenum; pname: GLenum; params: PGLfloat); apicall;
  glTexParameteri: procedure (target: GLenum; pname: GLenum; param: GLint); apicall;
  glTexParameteriv: procedure (target: GLenum; pname: GLenum; params: PGLint); apicall;
  glTexSubImage2D: procedure (target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; width: GLsizei; height: GLsizei; format: GLenum; type_: GLenum; pixels: Pointer); apicall;
  glUniform1f: procedure (location: GLint; v0: GLfloat); apicall;
  glUniform1fv: procedure (location: GLint; count: GLsizei; value: PGLfloat); apicall;
  glUniform1i: procedure (location: GLint; v0: GLint); apicall;
  glUniform1iv: procedure (location: GLint; count: GLsizei; value: PGLint); apicall;
  glUniform2f: procedure (location: GLint; v0: GLfloat; v1: GLfloat); apicall;
  glUniform2fv: procedure (location: GLint; count: GLsizei; value: PGLfloat); apicall;
  glUniform2i: procedure (location: GLint; v0: GLint; v1: GLint); apicall;
  glUniform2iv: procedure (location: GLint; count: GLsizei; value: PGLint); apicall;
  glUniform3f: procedure (location: GLint; v0: GLfloat; v1: GLfloat; v2: GLfloat); apicall;
  glUniform3fv: procedure (location: GLint; count: GLsizei; value: PGLfloat); apicall;
  glUniform3i: procedure (location: GLint; v0: GLint; v1: GLint; v2: GLint); apicall;
  glUniform3iv: procedure (location: GLint; count: GLsizei; value: PGLint); apicall;
  glUniform4f: procedure (location: GLint; v0: GLfloat; v1: GLfloat; v2: GLfloat; v3: GLfloat); apicall;
  glUniform4fv: procedure (location: GLint; count: GLsizei; value: PGLfloat); apicall;
  glUniform4i: procedure (location: GLint; v0: GLint; v1: GLint; v2: GLint; v3: GLint); apicall;
  glUniform4iv: procedure (location: GLint; count: GLsizei; value: PGLint); apicall;
  glUniformMatrix2fv: procedure (location: GLint; count: GLsizei; transpose: GLboolean; value: PGLfloat); apicall;
  glUniformMatrix3fv: procedure (location: GLint; count: GLsizei; transpose: GLboolean; value: PGLfloat); apicall;
  glUniformMatrix4fv: procedure (location: GLint; count: GLsizei; transpose: GLboolean; value: PGLfloat); apicall;
  glUseProgram: procedure (program_: GLuint); apicall;
  glValidateProgram: procedure (program_: GLuint); apicall;
  glVertexAttrib1f: procedure (index: GLuint; x: GLfloat); apicall;
  glVertexAttrib1fv: procedure (index: GLuint; v: PGLfloat); apicall;
  glVertexAttrib2f: procedure (index: GLuint; x: GLfloat; y: GLfloat); apicall;
  glVertexAttrib2fv: procedure (index: GLuint; v: PGLfloat); apicall;
  glVertexAttrib3f: procedure (index: GLuint; x: GLfloat; y: GLfloat; z: GLfloat); apicall;
  glVertexAttrib3fv: procedure (index: GLuint; v: PGLfloat); apicall;
  glVertexAttrib4f: procedure (index: GLuint; x: GLfloat; y: GLfloat; z: GLfloat; w: GLfloat); apicall;
  glVertexAttrib4fv: procedure (index: GLuint; v: PGLfloat); apicall;
  glVertexAttribPointer: procedure (index: GLuint; size: GLint; type_: GLenum; normalized: GLboolean; stride: GLsizei; pointer: Pointer); apicall;
  glViewport: procedure (x: GLint; y: GLint; width: GLsizei; height: GLsizei); apicall;

function LoadOpenGLES: Boolean;

implementation

var
  Loaded: Boolean;
  LoadedSuccess: Boolean;
  LibHandle: TLibHandle;

function Load(const ProcName: string): Pointer;
begin
  Result := GetProcAddress(LibHandle, ProcName);
end;

function LoadOpenGLES: Boolean;
const
  LibName =
  {$if defined(windows)}
  'opengl32.dll'
  {$elseif defined(darwin)}
  '/System/Library/Frameworks/OpenGL.framework/Libraries/libGL.dylib'
  {$else}
  'libGL.so';
  {$endif}

begin
  Result := LoadedSuccess;
  if Loaded then
    Exit;
  Loaded := True;
  LibHandle := LoadLibrary(LibName);
  if LibHandle = 0 then
    Exit;
  @glActiveTexture := Load('glActiveTexture'); if @glActiveTexture = nil then Exit;
  @glAttachShader := Load('glAttachShader'); if @glAttachShader = nil then Exit;
  @glBindAttribLocation := Load('glBindAttribLocation'); if @glBindAttribLocation = nil then Exit;
  @glBindBuffer := Load('glBindBuffer'); if @glBindBuffer = nil then Exit;
  @glBindFramebuffer := Load('glBindFramebuffer'); if @glBindFramebuffer = nil then Exit;
  @glBindRenderbuffer := Load('glBindRenderbuffer'); if @glBindRenderbuffer = nil then Exit;
  @glBindTexture := Load('glBindTexture'); if @glBindTexture = nil then Exit;
  @glBlendColor := Load('glBlendColor'); if @glBlendColor = nil then Exit;
  @glBlendEquation := Load('glBlendEquation'); if @glBlendEquation = nil then Exit;
  @glBlendEquationSeparate := Load('glBlendEquationSeparate'); if @glBlendEquationSeparate = nil then Exit;
  @glBlendFunc := Load('glBlendFunc'); if @glBlendFunc = nil then Exit;
  @glBlendFuncSeparate := Load('glBlendFuncSeparate'); if @glBlendFuncSeparate = nil then Exit;
  @glBufferData := Load('glBufferData'); if @glBufferData = nil then Exit;
  @glBufferSubData := Load('glBufferSubData'); if @glBufferSubData = nil then Exit;
  @glCheckFramebufferStatus := Load('glCheckFramebufferStatus'); if @glCheckFramebufferStatus = nil then Exit;
  @glClear := Load('glClear'); if @glClear = nil then Exit;
  @glClearColor := Load('glClearColor'); if @glClearColor = nil then Exit;
  @glClearDepthf := Load('glClearDepthf'); if @glClearDepthf = nil then Exit;
  @glClearStencil := Load('glClearStencil'); if @glClearStencil = nil then Exit;
  @glColorMask := Load('glColorMask'); if @glColorMask = nil then Exit;
  @glCompileShader := Load('glCompileShader'); if @glCompileShader = nil then Exit;
  @glCompressedTexImage2D := Load('glCompressedTexImage2D'); if @glCompressedTexImage2D = nil then Exit;
  @glCompressedTexSubImage2D := Load('glCompressedTexSubImage2D'); if @glCompressedTexSubImage2D = nil then Exit;
  @glCopyTexImage2D := Load('glCopyTexImage2D'); if @glCopyTexImage2D = nil then Exit;
  @glCopyTexSubImage2D := Load('glCopyTexSubImage2D'); if @glCopyTexSubImage2D = nil then Exit;
  @glCreateProgram := Load('glCreateProgram'); if @glCreateProgram = nil then Exit;
  @glCreateShader := Load('glCreateShader'); if @glCreateShader = nil then Exit;
  @glCullFace := Load('glCullFace'); if @glCullFace = nil then Exit;
  @glDeleteBuffers := Load('glDeleteBuffers'); if @glDeleteBuffers = nil then Exit;
  @glDeleteFramebuffers := Load('glDeleteFramebuffers'); if @glDeleteFramebuffers = nil then Exit;
  @glDeleteProgram := Load('glDeleteProgram'); if @glDeleteProgram = nil then Exit;
  @glDeleteRenderbuffers := Load('glDeleteRenderbuffers'); if @glDeleteRenderbuffers = nil then Exit;
  @glDeleteShader := Load('glDeleteShader'); if @glDeleteShader = nil then Exit;
  @glDeleteTextures := Load('glDeleteTextures'); if @glDeleteTextures = nil then Exit;
  @glDepthFunc := Load('glDepthFunc'); if @glDepthFunc = nil then Exit;
  @glDepthMask := Load('glDepthMask'); if @glDepthMask = nil then Exit;
  @glDepthRangef := Load('glDepthRangef'); if @glDepthRangef = nil then Exit;
  @glDetachShader := Load('glDetachShader'); if @glDetachShader = nil then Exit;
  @glDisable := Load('glDisable'); if @glDisable = nil then Exit;
  @glDisableVertexAttribArray := Load('glDisableVertexAttribArray'); if @glDisableVertexAttribArray = nil then Exit;
  @glDrawArrays := Load('glDrawArrays'); if @glDrawArrays = nil then Exit;
  @glDrawElements := Load('glDrawElements'); if @glDrawElements = nil then Exit;
  @glEnable := Load('glEnable'); if @glEnable = nil then Exit;
  @glEnableVertexAttribArray := Load('glEnableVertexAttribArray'); if @glEnableVertexAttribArray = nil then Exit;
  @glFinish := Load('glFinish'); if @glFinish = nil then Exit;
  @glFlush := Load('glFlush'); if @glFlush = nil then Exit;
  @glFramebufferRenderbuffer := Load('glFramebufferRenderbuffer'); if @glFramebufferRenderbuffer = nil then Exit;
  @glFramebufferTexture2D := Load('glFramebufferTexture2D'); if @glFramebufferTexture2D = nil then Exit;
  @glFrontFace := Load('glFrontFace'); if @glFrontFace = nil then Exit;
  @glGenBuffers := Load('glGenBuffers'); if @glGenBuffers = nil then Exit;
  @glGenerateMipmap := Load('glGenerateMipmap'); if @glGenerateMipmap = nil then Exit;
  @glGenFramebuffers := Load('glGenFramebuffers'); if @glGenFramebuffers = nil then Exit;
  @glGenRenderbuffers := Load('glGenRenderbuffers'); if @glGenRenderbuffers = nil then Exit;
  @glGenTextures := Load('glGenTextures'); if @glGenTextures = nil then Exit;
  @glGetActiveAttrib := Load('glGetActiveAttrib'); if @glGetActiveAttrib = nil then Exit;
  @glGetActiveUniform := Load('glGetActiveUniform'); if @glGetActiveUniform = nil then Exit;
  @glGetAttachedShaders := Load('glGetAttachedShaders'); if @glGetAttachedShaders = nil then Exit;
  @glGetAttribLocation := Load('glGetAttribLocation'); if @glGetAttribLocation = nil then Exit;
  @glGetBooleanv := Load('glGetBooleanv'); if @glGetBooleanv = nil then Exit;
  @glGetBufferParameteriv := Load('glGetBufferParameteriv'); if @glGetBufferParameteriv = nil then Exit;
  @glGetError := Load('glGetError'); if @glGetError = nil then Exit;
  @glGetFloatv := Load('glGetFloatv'); if @glGetFloatv = nil then Exit;
  @glGetFramebufferAttachmentParameteriv := Load('glGetFramebufferAttachmentParameteriv'); if @glGetFramebufferAttachmentParameteriv = nil then Exit;
  @glGetIntegerv := Load('glGetIntegerv'); if @glGetIntegerv = nil then Exit;
  @glGetProgramiv := Load('glGetProgramiv'); if @glGetProgramiv = nil then Exit;
  @glGetProgramInfoLog := Load('glGetProgramInfoLog'); if @glGetProgramInfoLog = nil then Exit;
  @glGetRenderbufferParameteriv := Load('glGetRenderbufferParameteriv'); if @glGetRenderbufferParameteriv = nil then Exit;
  @glGetShaderiv := Load('glGetShaderiv'); if @glGetShaderiv = nil then Exit;
  @glGetShaderInfoLog := Load('glGetShaderInfoLog'); if @glGetShaderInfoLog = nil then Exit;
  @glGetShaderPrecisionFormat := Load('glGetShaderPrecisionFormat'); if @glGetShaderPrecisionFormat = nil then Exit;
  @glGetShaderSource := Load('glGetShaderSource'); if @glGetShaderSource = nil then Exit;
  @glGetString := Load('glGetString'); if @glGetString = nil then Exit;
  @glGetTexParameterfv := Load('glGetTexParameterfv'); if @glGetTexParameterfv = nil then Exit;
  @glGetTexParameteriv := Load('glGetTexParameteriv'); if @glGetTexParameteriv = nil then Exit;
  @glGetUniformfv := Load('glGetUniformfv'); if @glGetUniformfv = nil then Exit;
  @glGetUniformiv := Load('glGetUniformiv'); if @glGetUniformiv = nil then Exit;
  @glGetUniformLocation := Load('glGetUniformLocation'); if @glGetUniformLocation = nil then Exit;
  @glGetVertexAttribfv := Load('glGetVertexAttribfv'); if @glGetVertexAttribfv = nil then Exit;
  @glGetVertexAttribiv := Load('glGetVertexAttribiv'); if @glGetVertexAttribiv = nil then Exit;
  @glGetVertexAttribPointerv := Load('glGetVertexAttribPointerv'); if @glGetVertexAttribPointerv = nil then Exit;
  @glHint := Load('glHint'); if @glHint = nil then Exit;
  @glIsBuffer := Load('glIsBuffer'); if @glIsBuffer = nil then Exit;
  @glIsEnabled := Load('glIsEnabled'); if @glIsEnabled = nil then Exit;
  @glIsFramebuffer := Load('glIsFramebuffer'); if @glIsFramebuffer = nil then Exit;
  @glIsProgram := Load('glIsProgram'); if @glIsProgram = nil then Exit;
  @glIsRenderbuffer := Load('glIsRenderbuffer'); if @glIsRenderbuffer = nil then Exit;
  @glIsShader := Load('glIsShader'); if @glIsShader = nil then Exit;
  @glIsTexture := Load('glIsTexture'); if @glIsTexture = nil then Exit;
  @glLineWidth := Load('glLineWidth'); if @glLineWidth = nil then Exit;
  @glLinkProgram := Load('glLinkProgram'); if @glLinkProgram = nil then Exit;
  @glPixelStorei := Load('glPixelStorei'); if @glPixelStorei = nil then Exit;
  @glPolygonOffset := Load('glPolygonOffset'); if @glPolygonOffset = nil then Exit;
  @glReadPixels := Load('glReadPixels'); if @glReadPixels = nil then Exit;
  @glReleaseShaderCompiler := Load('glReleaseShaderCompiler'); if @glReleaseShaderCompiler = nil then Exit;
  @glRenderbufferStorage := Load('glRenderbufferStorage'); if @glRenderbufferStorage = nil then Exit;
  @glSampleCoverage := Load('glSampleCoverage'); if @glSampleCoverage = nil then Exit;
  @glScissor := Load('glScissor'); if @glScissor = nil then Exit;
  @glShaderBinary := Load('glShaderBinary'); if @glShaderBinary = nil then Exit;
  @glShaderSource := Load('glShaderSource'); if @glShaderSource = nil then Exit;
  @glStencilFunc := Load('glStencilFunc'); if @glStencilFunc = nil then Exit;
  @glStencilFuncSeparate := Load('glStencilFuncSeparate'); if @glStencilFuncSeparate = nil then Exit;
  @glStencilMask := Load('glStencilMask'); if @glStencilMask = nil then Exit;
  @glStencilMaskSeparate := Load('glStencilMaskSeparate'); if @glStencilMaskSeparate = nil then Exit;
  @glStencilOp := Load('glStencilOp'); if @glStencilOp = nil then Exit;
  @glStencilOpSeparate := Load('glStencilOpSeparate'); if @glStencilOpSeparate = nil then Exit;
  @glTexImage2D := Load('glTexImage2D'); if @glTexImage2D = nil then Exit;
  @glTexParameterf := Load('glTexParameterf'); if @glTexParameterf = nil then Exit;
  @glTexParameterfv := Load('glTexParameterfv'); if @glTexParameterfv = nil then Exit;
  @glTexParameteri := Load('glTexParameteri'); if @glTexParameteri = nil then Exit;
  @glTexParameteriv := Load('glTexParameteriv'); if @glTexParameteriv = nil then Exit;
  @glTexSubImage2D := Load('glTexSubImage2D'); if @glTexSubImage2D = nil then Exit;
  @glUniform1f := Load('glUniform1f'); if @glUniform1f = nil then Exit;
  @glUniform1fv := Load('glUniform1fv'); if @glUniform1fv = nil then Exit;
  @glUniform1i := Load('glUniform1i'); if @glUniform1i = nil then Exit;
  @glUniform1iv := Load('glUniform1iv'); if @glUniform1iv = nil then Exit;
  @glUniform2f := Load('glUniform2f'); if @glUniform2f = nil then Exit;
  @glUniform2fv := Load('glUniform2fv'); if @glUniform2fv = nil then Exit;
  @glUniform2i := Load('glUniform2i'); if @glUniform2i = nil then Exit;
  @glUniform2iv := Load('glUniform2iv'); if @glUniform2iv = nil then Exit;
  @glUniform3f := Load('glUniform3f'); if @glUniform3f = nil then Exit;
  @glUniform3fv := Load('glUniform3fv'); if @glUniform3fv = nil then Exit;
  @glUniform3i := Load('glUniform3i'); if @glUniform3i = nil then Exit;
  @glUniform3iv := Load('glUniform3iv'); if @glUniform3iv = nil then Exit;
  @glUniform4f := Load('glUniform4f'); if @glUniform4f = nil then Exit;
  @glUniform4fv := Load('glUniform4fv'); if @glUniform4fv = nil then Exit;
  @glUniform4i := Load('glUniform4i'); if @glUniform4i = nil then Exit;
  @glUniform4iv := Load('glUniform4iv'); if @glUniform4iv = nil then Exit;
  @glUniformMatrix2fv := Load('glUniformMatrix2fv'); if @glUniformMatrix2fv = nil then Exit;
  @glUniformMatrix3fv := Load('glUniformMatrix3fv'); if @glUniformMatrix3fv = nil then Exit;
  @glUniformMatrix4fv := Load('glUniformMatrix4fv'); if @glUniformMatrix4fv = nil then Exit;
  @glUseProgram := Load('glUseProgram'); if @glUseProgram = nil then Exit;
  @glValidateProgram := Load('glValidateProgram'); if @glValidateProgram = nil then Exit;
  @glVertexAttrib1f := Load('glVertexAttrib1f'); if @glVertexAttrib1f = nil then Exit;
  @glVertexAttrib1fv := Load('glVertexAttrib1fv'); if @glVertexAttrib1fv = nil then Exit;
  @glVertexAttrib2f := Load('glVertexAttrib2f'); if @glVertexAttrib2f = nil then Exit;
  @glVertexAttrib2fv := Load('glVertexAttrib2fv'); if @glVertexAttrib2fv = nil then Exit;
  @glVertexAttrib3f := Load('glVertexAttrib3f'); if @glVertexAttrib3f = nil then Exit;
  @glVertexAttrib3fv := Load('glVertexAttrib3fv'); if @glVertexAttrib3fv = nil then Exit;
  @glVertexAttrib4f := Load('glVertexAttrib4f'); if @glVertexAttrib4f = nil then Exit;
  @glVertexAttrib4fv := Load('glVertexAttrib4fv'); if @glVertexAttrib4fv = nil then Exit;
  @glVertexAttribPointer := Load('glVertexAttribPointer'); if @glVertexAttribPointer = nil then Exit;
  @glViewport := Load('glViewport'); if @glViewport = nil then Exit;
  LoadedSuccess := True;
  Result := LoadedSuccess;
end;

end.
